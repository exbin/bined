/*
 * Copyright (C) ExBin Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.exbin.framework.bined.inspector.gui;

import java.awt.Font;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.math.BigInteger;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.InputMismatchException;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import org.exbin.bined.CodeAreaCaretPosition;
import org.exbin.bined.operation.command.BinaryDataCommand;
import org.exbin.bined.operation.swing.command.CodeAreaCompoundCommand;
import org.exbin.bined.operation.swing.command.InsertDataCommand;
import org.exbin.bined.operation.swing.command.ModifyDataCommand;
import org.exbin.framework.language.api.LanguageModuleApi;
import org.exbin.auxiliary.binary_data.BinaryData;
import org.exbin.auxiliary.binary_data.array.ByteArrayEditableData;
import org.exbin.auxiliary.binary_data.EditableBinaryData;
import org.exbin.bined.capability.CaretCapable;
import org.exbin.bined.operation.command.BinaryDataUndoRedo;
import org.exbin.framework.App;
import org.exbin.framework.bined.inspector.BasicValuesPositionColorModifier;
import org.exbin.bined.capability.CharsetCapable;
import org.exbin.bined.swing.CodeAreaCore;
import org.exbin.framework.bined.inspector.BinedInspectorModule;

/**
 * Values side panel.
 *
 * @author ExBin Project (https://exbin.org)
 */
@ParametersAreNonnullByDefault
public class BasicValuesPanel extends javax.swing.JPanel {

    public static final int UBYTE_MAX_VALUE = 255;
    public static final int SWORD_MIN_VALUE = -32768;
    public static final int SWORD_MAX_VALUE = 32767;
    public static final int UWORD_MAX_VALUE = 65535;
    public static final long UINT_MAX_VALUE = 4294967295L;
    public static final BigInteger ULONG_MAX_VALUE = new BigInteger("4294967295");
    public static final BigInteger BIG_INTEGER_BYTE_MASK = BigInteger.valueOf(255);
    public static final String VALUE_OUT_OF_RANGE_EXCEPTION = "Value is out of range";
    public static int CACHE_SIZE = 250;

    private final java.util.ResourceBundle resourceBundle = App.getModule(LanguageModuleApi.class).getBundle(BasicValuesPanel.class);
    private CodeAreaCore codeArea;
    private BinaryDataUndoRedo undoRedo;
    private long dataPosition;

    private final byte[] valuesCache = new byte[CACHE_SIZE];
    private final ByteBuffer byteBuffer = ByteBuffer.wrap(valuesCache);
    private final ValuesUpdater valuesUpdater = new ValuesUpdater();

    public BasicValuesPanel() {
        initComponents();
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        endianButtonGroup = new javax.swing.ButtonGroup();
        integerSignButtonGroup = new javax.swing.ButtonGroup();
        binaryLabel = createLabel();
        binaryCheckBox0 = createCheckBox();
        binaryCheckBox1 = createCheckBox();
        binaryCheckBox2 = createCheckBox();
        binaryCheckBox3 = createCheckBox();
        binaryCheckBox4 = createCheckBox();
        binaryCheckBox5 = createCheckBox();
        binaryCheckBox6 = createCheckBox();
        binaryCheckBox7 = createCheckBox();
        byteLabel = createLabel();
        byteTextField = createTextField();
        wordLabel = createLabel();
        wordTextField = createTextField();
        intLabel = createLabel();
        intTextField = createTextField();
        longLabel = createLabel();
        longTextField = createTextField();
        floatLabel = createLabel();
        floatTextField = createTextField();
        doubleLabel = createLabel();
        doubleTextField = createTextField();
        characterLabel = createLabel();
        characterTextField = createTextField();
        stringLabel = createLabel();
        stringTextField = createTextField();
        jSeparator1 = new javax.swing.JSeparator();
        bigEndianRadioButton = createRadioButton();
        littleEndianRadioButton = createRadioButton();
        signedRadioButton = createRadioButton();
        unsignedRadioButton = createRadioButton();

        binaryLabel.setText(resourceBundle.getString("binaryLabel.text")); // NOI18N

        binaryCheckBox0.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox0ActionPerformed(evt);
            }
        });

        binaryCheckBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox1ActionPerformed(evt);
            }
        });

        binaryCheckBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox2ActionPerformed(evt);
            }
        });

        binaryCheckBox3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox3ActionPerformed(evt);
            }
        });

        binaryCheckBox4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox4ActionPerformed(evt);
            }
        });

        binaryCheckBox5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox5ActionPerformed(evt);
            }
        });

        binaryCheckBox6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox6ActionPerformed(evt);
            }
        });

        binaryCheckBox7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binaryCheckBox7ActionPerformed(evt);
            }
        });

        byteLabel.setText(resourceBundle.getString("byteLabel.text")); // NOI18N

        byteTextField.setEditable(false);
        byteTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                byteTextFieldKeyReleased(evt);
            }
        });

        wordLabel.setText(resourceBundle.getString("wordLabel.text")); // NOI18N

        wordTextField.setEditable(false);
        wordTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                wordTextFieldKeyReleased(evt);
            }
        });

        intLabel.setText(resourceBundle.getString("intLabel.text")); // NOI18N

        intTextField.setEditable(false);
        intTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                intTextFieldKeyReleased(evt);
            }
        });

        longLabel.setText(resourceBundle.getString("longLabel.text")); // NOI18N

        longTextField.setEditable(false);
        longTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                longTextFieldKeyReleased(evt);
            }
        });

        floatLabel.setText(resourceBundle.getString("floatLabel.text")); // NOI18N

        floatTextField.setEditable(false);
        floatTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                floatTextFieldKeyReleased(evt);
            }
        });

        doubleLabel.setText(resourceBundle.getString("doubleLabel.text")); // NOI18N

        doubleTextField.setEditable(false);
        doubleTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                doubleTextFieldKeyReleased(evt);
            }
        });

        characterLabel.setText(resourceBundle.getString("characterLabel.text")); // NOI18N

        characterTextField.setEditable(false);
        characterTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                characterTextFieldKeyReleased(evt);
            }
        });

        stringLabel.setText(resourceBundle.getString("stringLabel.text")); // NOI18N

        stringTextField.setEditable(false);
        stringTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                stringTextFieldKeyReleased(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        endianButtonGroup.add(bigEndianRadioButton);
        bigEndianRadioButton.setSelected(true);
        bigEndianRadioButton.setText(resourceBundle.getString("bigEndianRadioButton.text")); // NOI18N
        bigEndianRadioButton.setToolTipText(resourceBundle.getString("bigEndianRadioButton.toolTipText")); // NOI18N
        bigEndianRadioButton.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                bigEndianRadioButtonItemStateChanged(evt);
            }
        });

        endianButtonGroup.add(littleEndianRadioButton);
        littleEndianRadioButton.setText(resourceBundle.getString("littleEndianRadioButton.text")); // NOI18N
        littleEndianRadioButton.setToolTipText(resourceBundle.getString("littleEndianRadioButton.toolTipText")); // NOI18N
        littleEndianRadioButton.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                littleEndianRadioButtonItemStateChanged(evt);
            }
        });

        integerSignButtonGroup.add(signedRadioButton);
        signedRadioButton.setSelected(true);
        signedRadioButton.setText(resourceBundle.getString("signedRadioButton.text")); // NOI18N
        signedRadioButton.setToolTipText(resourceBundle.getString("signedRadioButton.toolTipText")); // NOI18N
        signedRadioButton.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                signedRadioButtonItemStateChanged(evt);
            }
        });

        integerSignButtonGroup.add(unsignedRadioButton);
        unsignedRadioButton.setText(resourceBundle.getString("unsignedRadioButton.text")); // NOI18N
        unsignedRadioButton.setToolTipText(resourceBundle.getString("unsignedRadioButton.toolTipText")); // NOI18N
        unsignedRadioButton.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                unsignedRadioButtonItemStateChanged(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(bigEndianRadioButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(littleEndianRadioButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(signedRadioButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(unsignedRadioButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(characterTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(byteTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(wordTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(intTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(longTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(floatTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(byteLabel)
                            .addComponent(wordLabel)
                            .addComponent(intLabel)
                            .addComponent(longLabel)
                            .addComponent(binaryLabel)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(binaryCheckBox0)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox1)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox2)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox3)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox4)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox5)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox6)
                                .addGap(0, 0, 0)
                                .addComponent(binaryCheckBox7))
                            .addComponent(floatLabel)
                            .addComponent(doubleLabel)
                            .addComponent(doubleTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(characterLabel)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(stringTextField, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(stringLabel)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(binaryLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(binaryCheckBox0)
                    .addComponent(binaryCheckBox1)
                    .addComponent(binaryCheckBox2)
                    .addComponent(binaryCheckBox3)
                    .addComponent(binaryCheckBox4)
                    .addComponent(binaryCheckBox5)
                    .addComponent(binaryCheckBox6)
                    .addComponent(binaryCheckBox7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(byteLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(byteTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(wordLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(wordTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(intLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(intTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(longLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(longTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(floatLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(floatTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(doubleLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(doubleTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(characterLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(characterTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stringLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stringTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(bigEndianRadioButton)
                        .addComponent(littleEndianRadioButton))
                    .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(signedRadioButton)
                        .addComponent(unsignedRadioButton)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void binaryCheckBox0ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox0ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x80) > 0 != binaryCheckBox0.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x80);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox0ActionPerformed

    private void binaryCheckBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox1ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x40) > 0 != binaryCheckBox1.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x40);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox1ActionPerformed

    private void binaryCheckBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox2ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x20) > 0 != binaryCheckBox2.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x20);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox2ActionPerformed

    private void binaryCheckBox3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox3ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x10) > 0 != binaryCheckBox3.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x10);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox3ActionPerformed

    private void binaryCheckBox4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox4ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x8) > 0 != binaryCheckBox4.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x8);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox4ActionPerformed

    private void binaryCheckBox5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox5ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x4) > 0 != binaryCheckBox5.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x4);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox5ActionPerformed

    private void binaryCheckBox6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox6ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x2) > 0 != binaryCheckBox6.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x2);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox6ActionPerformed

    private void binaryCheckBox7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox7ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x1) > 0 != binaryCheckBox7.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x1);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox7ActionPerformed

    private void byteTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_byteTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                int intValue = Integer.parseInt(byteTextField.getText());
                if (isSigned()) {
                    if (intValue < Byte.MIN_VALUE || intValue > Byte.MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }
                } else {
                    if (intValue < 0 || intValue > UBYTE_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }
                }

                valuesCache[0] = (byte) intValue;
                modifyValues(1);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_byteTextFieldKeyReleased

    private void wordTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_wordTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                int intValue = Integer.parseInt(wordTextField.getText());
                if (isSigned()) {
                    if (intValue < SWORD_MIN_VALUE || intValue > SWORD_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }
                } else {
                    if (intValue < 0 || intValue > UWORD_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }
                }

                if (getByteOrder() == ByteOrder.LITTLE_ENDIAN) {
                    valuesCache[0] = (byte) (intValue & 0xff);
                    valuesCache[1] = (byte) ((intValue >> 8) & 0xff);
                } else {
                    valuesCache[0] = (byte) ((intValue >> 8) & 0xff);
                    valuesCache[1] = (byte) (intValue & 0xff);
                }
                modifyValues(2);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_wordTextFieldKeyReleased

    private void intTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_intTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                long longValue = Long.parseLong(intTextField.getText());
                if (isSigned()) {
                    if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }
                } else {
                    if (longValue < 0 || longValue > UINT_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }
                }

                if (getByteOrder() == ByteOrder.LITTLE_ENDIAN) {
                    valuesCache[0] = (byte) (longValue & 0xff);
                    valuesCache[1] = (byte) ((longValue >> 8) & 0xff);
                    valuesCache[2] = (byte) ((longValue >> 16) & 0xff);
                    valuesCache[3] = (byte) ((longValue >> 24) & 0xff);
                } else {
                    valuesCache[0] = (byte) ((longValue >> 24) & 0xff);
                    valuesCache[1] = (byte) ((longValue >> 16) & 0xff);
                    valuesCache[2] = (byte) ((longValue >> 8) & 0xff);
                    valuesCache[3] = (byte) (longValue & 0xff);
                }
                modifyValues(4);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_intTextFieldKeyReleased

    private void longTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_longTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                ByteOrder byteOrder = getByteOrder();
                if (isSigned()) {
                    long longValue = Long.parseLong(longTextField.getText());

                    ((Buffer) byteBuffer).rewind();
                    if (byteBuffer.order() != byteOrder) {
                        byteBuffer.order(byteOrder);
                    }

                    byteBuffer.putLong(longValue);
                } else {
                    BigInteger bigInteger = new BigInteger(longTextField.getText());
                    if (bigInteger.compareTo(BigInteger.ZERO) == -1 || bigInteger.compareTo(ULONG_MAX_VALUE) == 1) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE_EXCEPTION);
                    }

                    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
                        for (int i = 0; i < 7; i++) {
                            BigInteger nextByte = bigInteger.and(BIG_INTEGER_BYTE_MASK);
                            valuesCache[7 - i] = nextByte.byteValue();
                            bigInteger = bigInteger.shiftRight(8);
                        }
                    } else {
                        for (int i = 0; i < 7; i++) {
                            BigInteger nextByte = bigInteger.and(BIG_INTEGER_BYTE_MASK);
                            valuesCache[i] = nextByte.byteValue();
                            bigInteger = bigInteger.shiftRight(8);
                        }
                    }
                }

                modifyValues(8);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_longTextFieldKeyReleased

    private void floatTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_floatTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                ByteOrder byteOrder = getByteOrder();
                float floatValue = Float.parseFloat(floatTextField.getText());

                ((Buffer) byteBuffer).rewind();
                if (byteBuffer.order() != byteOrder) {
                    byteBuffer.order(byteOrder);
                }

                byteBuffer.putFloat(floatValue);

                modifyValues(4);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_floatTextFieldKeyReleased

    private void doubleTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_doubleTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                ByteOrder byteOrder = getByteOrder();
                double doubleValue = Double.parseDouble(doubleTextField.getText());

                ((Buffer) byteBuffer).rewind();
                if (byteBuffer.order() != byteOrder) {
                    byteBuffer.order(byteOrder);
                }

                byteBuffer.putDouble(doubleValue);

                modifyValues(8);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_doubleTextFieldKeyReleased

    private void characterTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_characterTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                String characterText = characterTextField.getText();
                if (characterText.isEmpty()) {
                    throw new InputMismatchException("Empty value not valid");
                }

                if (characterText.length() > 1) {
                    throw new InputMismatchException("Only single character allowed");
                }

                byte[] bytes = characterText.getBytes(((CharsetCapable) codeArea).getCharset());
                System.arraycopy(bytes, 0, valuesCache, 0, bytes.length);

                modifyValues(bytes.length);
                updateValues();
            } catch (InputMismatchException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_characterTextFieldKeyReleased

    private void stringTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_stringTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                String characterText = stringTextField.getText();
                if (characterText.isEmpty()) {
                    throw new InputMismatchException("Empty value not valid");
                }

                byte[] bytes = characterText.getBytes(((CharsetCapable) codeArea).getCharset());
                if (bytes.length > CACHE_SIZE) {
                    throw new InputMismatchException("String is too long");
                }
                System.arraycopy(bytes, 0, valuesCache, 0, bytes.length);

                modifyValues(bytes.length);
                updateValues();
            } catch (InputMismatchException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_stringTextFieldKeyReleased

    private void bigEndianRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_bigEndianRadioButtonItemStateChanged
        updateValues();
    }//GEN-LAST:event_bigEndianRadioButtonItemStateChanged

    private void littleEndianRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_littleEndianRadioButtonItemStateChanged
        updateValues();
    }//GEN-LAST:event_littleEndianRadioButtonItemStateChanged

    private void signedRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_signedRadioButtonItemStateChanged
        updateValues();
    }//GEN-LAST:event_signedRadioButtonItemStateChanged

    private void unsignedRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_unsignedRadioButtonItemStateChanged
        updateValues();
    }//GEN-LAST:event_unsignedRadioButtonItemStateChanged

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton bigEndianRadioButton;
    private javax.swing.JCheckBox binaryCheckBox0;
    private javax.swing.JCheckBox binaryCheckBox1;
    private javax.swing.JCheckBox binaryCheckBox2;
    private javax.swing.JCheckBox binaryCheckBox3;
    private javax.swing.JCheckBox binaryCheckBox4;
    private javax.swing.JCheckBox binaryCheckBox5;
    private javax.swing.JCheckBox binaryCheckBox6;
    private javax.swing.JCheckBox binaryCheckBox7;
    private javax.swing.JLabel binaryLabel;
    private javax.swing.JLabel byteLabel;
    private javax.swing.JTextField byteTextField;
    private javax.swing.JLabel characterLabel;
    private javax.swing.JTextField characterTextField;
    private javax.swing.JLabel doubleLabel;
    private javax.swing.JTextField doubleTextField;
    private javax.swing.ButtonGroup endianButtonGroup;
    private javax.swing.JLabel floatLabel;
    private javax.swing.JTextField floatTextField;
    private javax.swing.JLabel intLabel;
    private javax.swing.JTextField intTextField;
    private javax.swing.ButtonGroup integerSignButtonGroup;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JRadioButton littleEndianRadioButton;
    private javax.swing.JLabel longLabel;
    private javax.swing.JTextField longTextField;
    private javax.swing.JRadioButton signedRadioButton;
    private javax.swing.JLabel stringLabel;
    private javax.swing.JTextField stringTextField;
    private javax.swing.JRadioButton unsignedRadioButton;
    private javax.swing.JLabel wordLabel;
    private javax.swing.JTextField wordTextField;
    // End of variables declaration//GEN-END:variables

    public void setCodeArea(CodeAreaCore codeArea, @Nullable BinaryDataUndoRedo undoRedo) {
        this.codeArea = codeArea;
        this.undoRedo = undoRedo;

        BinedInspectorModule binedInspectorModule = App.getModule(BinedInspectorModule.class);
        registerFocusPainter(binedInspectorModule.getBasicValuesColorModifier());
    }

    @Nonnull
    public Font getInputFieldsFont() {
        Font font = byteTextField.getFont();
        if (font == null) {
            font = new Font(Font.SANS_SERIF, Font.PLAIN, 13);
        }
        return font;
    }

    public void setInputFieldsFont(Font font) {
        byteTextField.setFont(font);
        wordTextField.setFont(font);
        intTextField.setFont(font);
        longTextField.setFont(font);
        floatTextField.setFont(font);
        doubleTextField.setFont(font);
        characterTextField.setFont(font);
        stringTextField.setFont(font);
    }

    public void updateEditMode() {
        boolean editable = isEditable();
        binaryCheckBox0.setEnabled(editable);
        binaryCheckBox1.setEnabled(editable);
        binaryCheckBox2.setEnabled(editable);
        binaryCheckBox3.setEnabled(editable);
        binaryCheckBox4.setEnabled(editable);
        binaryCheckBox5.setEnabled(editable);
        binaryCheckBox6.setEnabled(editable);
        binaryCheckBox7.setEnabled(editable);
        byteTextField.setEditable(editable);
        wordTextField.setEditable(editable);
        intTextField.setEditable(editable);
        longTextField.setEditable(editable);
        floatTextField.setEditable(editable);
        doubleTextField.setEditable(editable);
        characterTextField.setEditable(editable);
        stringTextField.setEditable(editable);
    }

    public void updateValues() {
        CodeAreaCaretPosition caretPosition = ((CaretCapable) codeArea).getActiveCaretPosition();
        dataPosition = caretPosition.getDataPosition();
        long dataSize = codeArea.getDataSize();

        if (dataPosition < dataSize) {
            int availableData = dataSize - dataPosition >= CACHE_SIZE ? CACHE_SIZE : (int) (dataSize - dataPosition);
            BinaryData contentData = codeArea.getContentData();
            contentData.copyToArray(dataPosition, valuesCache, 0, availableData);
            if (availableData < CACHE_SIZE) {
                Arrays.fill(valuesCache, availableData, CACHE_SIZE, (byte) 0);
            }
        }

        valuesUpdater.schedule();
    }

    private void modifyValues(int bytesCount) {
        ByteArrayEditableData byteArrayData = new ByteArrayEditableData();
        byteArrayData.insert(0, valuesCache, 0, bytesCount);
        long oldDataPosition = dataPosition;
        if (dataPosition == codeArea.getDataSize()) {
            InsertDataCommand insertCommand = new InsertDataCommand(codeArea, dataPosition, ((CaretCapable) codeArea).getCodeOffset(), byteArrayData);
            if (undoRedo != null) {
                undoRedo.execute(insertCommand);
            }
        } else {
            BinaryDataCommand command;
            if (dataPosition + byteArrayData.getDataSize() > codeArea.getDataSize()) {
                long modifiedDataSize = codeArea.getDataSize() - dataPosition;
                EditableBinaryData modifiedData = (EditableBinaryData) byteArrayData.copy(0, modifiedDataSize);
                EditableBinaryData insertedData = (EditableBinaryData) byteArrayData.copy(modifiedDataSize, byteArrayData.getDataSize() - modifiedDataSize);
                command = new CodeAreaCompoundCommand(codeArea);
                ((CodeAreaCompoundCommand) command).addCommand(new ModifyDataCommand(codeArea, dataPosition, modifiedData));
                ((CodeAreaCompoundCommand) command).addCommand(new InsertDataCommand(codeArea, dataPosition + modifiedDataSize, ((CaretCapable) codeArea).getCodeOffset(), insertedData));
            } else {
                command = new ModifyDataCommand(codeArea, dataPosition, byteArrayData);
            }

            if (undoRedo != null) {
                undoRedo.execute(command);
            }
        }
        ((CaretCapable) codeArea).setActiveCaretPosition(oldDataPosition);
        codeArea.repaint();
    }

    private boolean isSigned() {
        return signedRadioButton.isSelected();
    }

    private boolean isEditable() {
        return codeArea.isEditable();
    }

    @Nonnull
    private ByteOrder getByteOrder() {
        return littleEndianRadioButton.isSelected() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
    }

    private void showException(Exception ex) {
        JOptionPane.showMessageDialog(this, ex.getMessage(), resourceBundle.getString("invalidInputError.message"), JOptionPane.ERROR_MESSAGE);
    }

    public enum ValuesPanelField {
        BINARY0,
        BINARY1,
        BINARY2,
        BINARY3,
        BINARY4,
        BINARY5,
        BINARY6,
        BINARY7,
        BYTE,
        WORD,
        INTEGER,
        LONG,
        FLOAT,
        DOUBLE,
        CHARACTER,
        STRING
    }

    public void registerFocusPainter(BasicValuesPositionColorModifier colorModifier) {
        byteTextField.addFocusListener(new ValueFocusListener(colorModifier, 1));
        wordTextField.addFocusListener(new ValueFocusListener(colorModifier, 2));
        intTextField.addFocusListener(new ValueFocusListener(colorModifier, 4));
        longTextField.addFocusListener(new ValueFocusListener(colorModifier, 8));
        floatTextField.addFocusListener(new ValueFocusListener(colorModifier, 4));
        doubleTextField.addFocusListener(new ValueFocusListener(colorModifier, 8));
        characterTextField.addFocusListener(new ValueFocusListener(colorModifier, 1));
        stringTextField.addFocusListener(new ValueFocusListener(colorModifier, 1));
    }

    @ParametersAreNonnullByDefault
    private class ValuesUpdater {

        private boolean updateInProgress = false;
        private boolean updateTerminated = false;
        private boolean scheduleUpdate = false;
        private boolean clearFields = true;

        private boolean signed;
        private ByteOrder byteOrder;
        private byte[] values;

        private synchronized void schedule() {
            if (updateInProgress) {
                updateTerminated = true;
            }
            if (!scheduleUpdate) {
                scheduleUpdate = true;
                scheduleNextStep(ValuesPanelField.values()[0]);
            }
        }

        private void scheduleNextStep(final ValuesPanelField valuesPanelField) {
            SwingUtilities.invokeLater(() -> updateValue(valuesPanelField));
        }

        public boolean isUpdateInProgress() {
            return updateInProgress;
        }

        private void updateValue(final ValuesPanelField valuesPanelField) {
            if (valuesPanelField.ordinal() == 0) {
                long dataSize = codeArea.getDataSize();
                clearFields = dataPosition >= dataSize;
                byteOrder = getByteOrder();
                signed = isSigned();
                values = valuesCache;
                if (clearFields) {
                    values[0] = 0;
                }
                updateStarted();
            }

            if (updateTerminated) {
                stopUpdate();
                return;
            }

            if (clearFields) {
                clearField(valuesPanelField);
            } else {
                updateField(valuesPanelField);
            }

            final ValuesPanelField[] panelFields = ValuesPanelField.values();
            ValuesPanelField lastValue = panelFields[panelFields.length - 1];
            if (valuesPanelField == lastValue) {
                stopUpdate();
            } else {
                SwingUtilities.invokeLater(() -> {
                    ValuesPanelField nextValue = panelFields[valuesPanelField.ordinal() + 1];
                    updateValue(nextValue);
                });
            }
        }

        private void updateField(ValuesPanelField valuesPanelField) {
            switch (valuesPanelField) {
                case BINARY0: {
                    binaryCheckBox0.setSelected((values[0] & 0x80) > 0);
                    break;
                }
                case BINARY1: {
                    binaryCheckBox1.setSelected((values[0] & 0x40) > 0);
                    break;
                }
                case BINARY2: {
                    binaryCheckBox2.setSelected((values[0] & 0x20) > 0);
                    break;
                }
                case BINARY3: {
                    binaryCheckBox3.setSelected((values[0] & 0x10) > 0);
                    break;
                }
                case BINARY4: {
                    binaryCheckBox4.setSelected((values[0] & 0x8) > 0);
                    break;
                }
                case BINARY5: {
                    binaryCheckBox5.setSelected((values[0] & 0x4) > 0);
                    break;
                }
                case BINARY6: {
                    binaryCheckBox6.setSelected((values[0] & 0x2) > 0);
                    break;
                }
                case BINARY7: {
                    binaryCheckBox7.setSelected((values[0] & 0x1) > 0);
                    break;
                }
                case BYTE: {
                    byteTextField.setText(String.valueOf(signed ? values[0] : values[0] & 0xff));
                    byteTextField.setCaretPosition(0);
                    break;
                }
                case WORD: {
                    int wordValue = signed
                            ? (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xff) | (values[1] << 8)
                                    : (values[1] & 0xff) | (values[0] << 8))
                            : (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xff) | ((values[1] & 0xff) << 8)
                                    : (values[1] & 0xff) | ((values[0] & 0xff) << 8));
                    wordTextField.setText(String.valueOf(wordValue));
                    wordTextField.setCaretPosition(0);
                    break;
                }
                case INTEGER: {
                    long intValue = signed
                            ? (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xffL) | ((values[1] & 0xffL) << 8) | ((values[2] & 0xffL) << 16) | (values[3] << 24)
                                    : (values[3] & 0xffL) | ((values[2] & 0xffL) << 8) | ((values[1] & 0xffL) << 16) | (values[0] << 24))
                            : (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xffL) | ((values[1] & 0xffL) << 8) | ((values[2] & 0xffL) << 16) | ((values[3] & 0xffL) << 24)
                                    : (values[3] & 0xffL) | ((values[2] & 0xffL) << 8) | ((values[1] & 0xffL) << 16) | ((values[0] & 0xffL) << 24));
                    intTextField.setText(String.valueOf(intValue));
                    intTextField.setCaretPosition(0);
                    break;
                }
                case LONG: {
                    if (signed) {
                        ((Buffer) byteBuffer).rewind();
                        if (byteBuffer.order() != byteOrder) {
                            byteBuffer.order(byteOrder);
                        }

                        longTextField.setText(String.valueOf(byteBuffer.getLong()));
                    } else {
                        long longValue = byteOrder == ByteOrder.LITTLE_ENDIAN
                                ? (values[0] & 0xffL) | ((values[1] & 0xffL) << 8) | ((values[2] & 0xffL) << 16) | ((values[3] & 0xffL) << 24)
                                | ((values[4] & 0xffL) << 32) | ((values[5] & 0xffL) << 40) | ((values[6] & 0xffL) << 48)
                                : (values[7] & 0xffL) | ((values[6] & 0xffL) << 8) | ((values[5] & 0xffL) << 16) | ((values[4] & 0xffL) << 24)
                                | ((values[3] & 0xffL) << 32) | ((values[2] & 0xffL) << 40) | ((values[1] & 0xffL) << 48);
                        BigInteger bigInt1 = BigInteger.valueOf(values[byteOrder == ByteOrder.LITTLE_ENDIAN ? 7 : 0] & 0xffL);
                        BigInteger bigInt2 = bigInt1.shiftLeft(56);
                        BigInteger bigInt3 = bigInt2.add(BigInteger.valueOf(longValue));
                        longTextField.setText(bigInt3.toString());
                    }
                    longTextField.setCaretPosition(0);
                    break;
                }
                case FLOAT: {
                    ((Buffer) byteBuffer).rewind();
                    if (byteBuffer.order() != byteOrder) {
                        byteBuffer.order(byteOrder);
                    }

                    floatTextField.setText(String.valueOf(byteBuffer.getFloat()));
                    floatTextField.setCaretPosition(0);
                    break;
                }
                case DOUBLE: {
                    ((Buffer) byteBuffer).rewind();
                    if (byteBuffer.order() != byteOrder) {
                        byteBuffer.order(byteOrder);
                    }

                    doubleTextField.setText(String.valueOf(byteBuffer.getDouble()));
                    doubleTextField.setCaretPosition(0);
                    break;
                }
                case CHARACTER: {
                    String strValue = new String(values, ((CharsetCapable) codeArea).getCharset());
                    if (!strValue.isEmpty()) {
                        characterTextField.setText(strValue.substring(0, 1));
                    } else {
                        characterTextField.setText("");
                    }
                    characterTextField.setCaretPosition(0);
                    break;
                }
                case STRING: {
                    String strValue = new String(values, ((CharsetCapable) codeArea).getCharset());
                    for (int i = 0; i < strValue.length(); i++) {
                        char charAt = strValue.charAt(i);
                        if (charAt == '\r' || charAt == '\n' || charAt == 0) {
                            strValue = strValue.substring(0, i);
                            break;
                        }
                    }
                    stringTextField.setText(strValue);
                    stringTextField.setCaretPosition(0);
                    break;
                }
            }
        }

        private void clearField(ValuesPanelField valuesPanelField) {
            switch (valuesPanelField) {
                case BINARY0: {
                    binaryCheckBox0.setSelected(false);
                    break;
                }
                case BINARY1: {
                    binaryCheckBox1.setSelected(false);
                    break;
                }
                case BINARY2: {
                    binaryCheckBox2.setSelected(false);
                    break;
                }
                case BINARY3: {
                    binaryCheckBox3.setSelected(false);
                    break;
                }
                case BINARY4: {
                    binaryCheckBox4.setSelected(false);
                    break;
                }
                case BINARY5: {
                    binaryCheckBox5.setSelected(false);
                    break;
                }
                case BINARY6: {
                    binaryCheckBox6.setSelected(false);
                    break;
                }
                case BINARY7: {
                    binaryCheckBox7.setSelected(false);
                    break;
                }
                case BYTE: {
                    byteTextField.setText("");
                    break;
                }
                case WORD: {
                    wordTextField.setText("");
                    break;
                }
                case INTEGER: {
                    intTextField.setText("");
                    break;
                }
                case LONG: {
                    longTextField.setText("");
                    break;
                }
                case FLOAT: {
                    floatTextField.setText("");
                    break;
                }
                case DOUBLE: {
                    doubleTextField.setText("");
                    break;
                }
                case CHARACTER: {
                    characterTextField.setText("");
                    break;
                }
                case STRING: {
                    stringTextField.setText("");
                    break;
                }
            }
        }

        private synchronized void updateStarted() {
            updateInProgress = true;
            scheduleUpdate = false;
        }

        private synchronized void stopUpdate() {
            updateInProgress = false;
            updateTerminated = false;
        }
    }

    @Nonnull
    protected JLabel createLabel() {
        return new JLabel();
    }

    @Nonnull
    protected JCheckBox createCheckBox() {
        return new JCheckBox();
    }

    @Nonnull
    protected JTextField createTextField() {
        return new JTextField();
    }

    @Nonnull
    protected JRadioButton createRadioButton() {
        return new JRadioButton();
    }

    @ParametersAreNonnullByDefault
    private class ValueFocusListener implements FocusListener {

        private BasicValuesPositionColorModifier colorModifier;
        private int length;

        public ValueFocusListener(BasicValuesPositionColorModifier colorModifier, int length) {
            this.colorModifier = colorModifier;
            this.length = length;
        }

        @Override
        public void focusGained(FocusEvent e) {
            colorModifier.setRange(dataPosition, length);
            codeArea.repaint();
        }

        @Override
        public void focusLost(FocusEvent e) {
            colorModifier.clearRange();
            codeArea.repaint();
        }
    }
}
